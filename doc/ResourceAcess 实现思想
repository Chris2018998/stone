内部结构设想
1：AtomicInteger totalCount = new AtomicInteger(0);//重入总次数
2: AtomicReference<ThreadNode> accessingHolder;//访问持有对象
3：ThreadLocal<Integer>reentrantHoldCount = new ThreadLocal<Integer>();//线程的重入计数器
4: ConcurrentLinkedQueue<ThreadNode> waitQueue = new ConcurrentLinkedQueue<>();//互斥等待队列

互斥申请
1：创建节点对象(node.value为节点类型 1：互斥]
2: cas尝试使用节点去抢占:accessingHolder
3：失败则取队列等待自旋

//申请1:（入口级方法）
public boolean acquire(int acquireType){
	//1：检查是否已经持有锁，如果持有则累计重入次数
	Integer threadreentrantCount = reentrantHoldCount.get();
	if(threadreentrantCount!=null&& threadreentrantCount.get()>0){
		if(totalCount.incrementAndGet()>0){//先累计总入数，再累计当前线程的重入数（可兼容读写两种模式）
			threadreentrantCount.set(threadreentrantCount++);//累计线程的重入次数
			return true;//计算为重入成功
		}
	}
	
	//2：只能加入自旋方法
	ThreadNode node = new ThreadNode(acquireType);
	ThreadParker nodeParker = ThreadParker.create();//依据具体情况创建 
	return acquire(node，nodeParker);
}

//申请2:（核心基础方法,支持来自Condition的Singal和Singal唤醒调用）
private boolean acquire(ThreadNode node,ThreadParker){
  //1: 直接抢占锁对象（accessingHolder）
  if(competeInd || waitQueue.isEmpty()){//竞争模式或等待队列为空
     if(accessingHolder.compareAndSwap(null,node){
		 afterAcquireSucess(node);
		 return true;
     }
   }
   
   //2: 自旋片段（核心代码）
   while(true){
	//.......省略详细代码
   }
   return false;
}

//申请成功后处理
private void afterAcquiredSucess(ThreadNode node){
	 int reentrantCount= totalCount.incrementAndGet();
	 threadreentrantCount.set(1);//累计
     if(node.getValue()==2 && reentrantCount==1){//第一个获得共享锁则通知队列其他共享等待者退出
	    //省略唤醒代码段
	 }
}

